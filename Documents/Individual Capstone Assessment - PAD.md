# Individual Capstone Assessment

For our senior design project, me and my teammate really wanted to work on a project within a field that excites us: Natural Language Processsing. We both want to utilize our respective expertise in NLP and general Software Engineering skills to tackle a real-world problem. Realistically, I envision that our project will be similar to the ideas presented in the hackathons that we sometimes participate together in, but it will definitely be different in scale and execution. To be honest, we still don't know exactly what problem we wish to tackle with AI, as problems tend to either fall in the "embarrashingly simple" bucket, or the "incredibly vague and possibly impossible to solve for now" bucket. We know that we wish to tackle problems within the field of education and/or technology in general, but the space is filled with an astounding number of "GPT-wrapper" styled app, fitting a couple of prompts surrounding a Large Language Model. We don't want to do something like that. We want to incorporate AI technology in a way that is interesting and creative to solve a problem. This is why we're spending a lot of time on the brainstorming phase, as hastily jumping into this space will inevitably leave us with an unsatisfying direction that will sooner or later be changed. Whatever problem we decide to solve with AI, we will most likely require a platform. I personally have a lot of experience with web applications, so I have a slight bias towards that direction, but I am also impartial to doing desktop applications, as there are ways to use the same technology for webapps on the desktop. Depending on the specifics of the problem, we might even write extensions to existing programs, like Chrome or Obsidian plugins. The way I see it, for us to successfully develop an AI-powered application for realistic problems, we will need to work on a comprehensive UI, as well as an interesting backend in AI wrangling.

Perhaps it is because I am taking Senior Design a year early, but I don't find my coursework to be particularly related to my senior design project. There is a standout course though: CS 5134 Natural Language Processing. I took this course in Spring 2024 with Professor Tianyu Jiang, who suggested the course to me as a good complement to my collaboration with him on NLP problems. The course went over the details of natural language processing techniques as it develops through time, from early techniques like n-grams to state-of-the-art techniques like transformers. Taking this course inspired me to develop my skills in the NLP space further than the curriculum and made me very interested about the developments in the field. I believe this project will allow me (and my teammate, he's also taken it) think critically about problems and apply appropriate NLP solutions instead of just using the big hammer of prompting Large Language Models.

My co-op experiences contribute more to my overall decision of project topic. My first co-op was working on a joint research effort with Dr. Atluri and the Cincinnati's Children's Hospital. During this co-op, I got a lot of exposure to general data wrangling and machine learning in the domain of medicine. I was already interested in AI in high school, but this project really allowed me to get real exposure on rigorous problem-solving in AI. My extensive experience gained from data cleaning, data visualization and feature engineering in this co-op will allow me to handle data more effectively in this project. My second co-op also had me do a lot of data wrangling and visualization work in general, but I believe the technical experience is mostly eclipsed by the first co-op. I believe the most valuable experience I get from my second co-op is general project management, collaboration and time management, as I've had to handle several projects over the term. I believe with these skills, I'll be able to help keep us on track for this senior design project. My third co-op also has to do with data management, but this time the context is more in terms of web technology and APIs. It was here that I've obtained web backend skills to aid our project should we require it. There is a very high chance of us working on a web application, or a desktop application with web technology and frameworks so I'd imagine this would be useful then.

I've participated in a few hackathons before, and won a few. In almost all of them, I've worked on AI-powered applications. I've been fascinated with the ways in which we use AI to solve daunting real world issues, issues that are impossible to solve with just plain software engineering. How do you write a program that recognizes birds without computer vision? How does your program know if its user is happy or sad without sentimental analysis? My fascination with AI runs deep, and it's often due to my fascination with intelligence as a whole. What really made me believe in AI though, is its ability to distribute intelligence on demand. A layperson equipped with the latest plant detection app can recognizes plants as well as a botanist would. A regular citizen with Google Translate will be able to communicate almost anywhere in the world. In the past, an increased ability in knowledge and intelligence distribution has always resulted in significiant societal progress. Basically, I want to take part in enabling this intelligence distribution because I believe it to be necessary for societal progress.

The brainstorming step is crucial for us. As I've mentioned before, it is very easy to either pick a laughably easy problem, or a problem that's next to impossible to solve in the AI domain. Once we've chosen a good problem to solve, we'll start with wireframing the user experience in the minimum viable product. We will list out the bare minimum features our application can have and still be a solid application. After that, we will design a UI, likely heavily depending on an existing UI library, with some mock data to simulate how a user might use our application. Then, we can work on the actual AI backend, as well as the server-side logic. If everything goes right, by the end, we will have built a functioning prototype of our application that's almost ready to ship to the world. We will know we are done once we've invited a few people who knows nothing about the project to try out the product and got through using it with no issues, and after testing our product's on some edge cases. We will know that we've done a good job when these testers are content with our prototype, and does not offer any feedback that disagree with our design principles.
